# **Veritaminal: Terminal-Based Document Verification Game Documentation**

## **Table of Contents**
1. [Introduction](#1-introduction)
2. [Project Overview](#2-project-overview)
3. [Game Concept and Mechanics](#3-game-concept-and-mechanics)
4. [Technical Requirements](#4-technical-requirements)
5. [Setting Up the Development Environment](#5-setting-up-the-development-environment)
6. [Project Structure](#6-project-structure)
7. [Core Functionality](#7-core-functionality)
   - [Document Generation](#71-document-generation)
   - [Commands and Gameplay](#72-commands-and-gameplay)
   - [Scoring System](#73-scoring-system)
8. [AI Assistant: Veritas](#8-ai-assistant-veritas)
9. [Narrative Branching](#9-narrative-branching)
10. [Testing and Debugging](#10-testing-and-debugging)
11. [Packaging and Deployment](#11-packaging-and-deployment)
12. [Contributing to the Project](#12-contributing-to-the-project)
13. [Troubleshooting](#13-troubleshooting)
14. [Future Enhancements](#14-future-enhancements)
15. [Appendix: Example Configuration](#15-appendix-example-configuration)

---

## **1. Introduction**
Welcome to **Veritaminal**, a terminal-based game where players act as border control agents, verifying AI-generated documents (e.g., passports, permits) to approve or deny travelers. This documentation is your complete guide to understanding, running, and extending the project. Whether you're a new developer or a seasoned coder, every detail you need is here—conceptual background, technical setup, code structure, and contribution guidelines—so you can take over seamlessly if I'm unavailable.

---

## **2. Project Overview**
**Veritaminal** is an interactive game that blends document verification with narrative storytelling. Players use a minimalist terminal interface to evaluate AI-generated traveler documents, guided by an AI assistant named **Veritas**. The game draws inspiration from "Papers, Please," but with dynamic content powered by the **Google Gemini AI API** and a focus on replayability through branching narratives.

### **Purpose**
- **For Players**: To challenge critical thinking and decision-making while immersing them in a story shaped by their choices.
- **For Developers**: To provide a modular, extensible codebase that demonstrates AI integration, terminal UI design, and narrative game mechanics.

### **Key Features**
- **Dynamic Content**: Traveler names, documents, and backstories generated by AI.
- **Verification Gameplay**: Players approve or deny based on evolving rules.
- **AI Assistant (Veritas)**: Offers hints and narrative commentary.
- **Narrative Branching**: Choices affect the story, leading to multiple endings.
- **Terminal-Based**: Lightweight and cross-platform.

### **Design Philosophy**
- **Minimalism**: A clean, distraction-free interface.
- **Clarity**: Rules and feedback are straightforward.
- **Curiosity**: Encourages players to explore truth and consequences.

---

## **3. Game Concept and Mechanics**
### **Objective**
Players verify documents to earn points, balancing accuracy with narrative consequences (e.g., corruption or trust levels).

### **Gameplay Loop**
1. **Document Presentation**: A traveler’s document (name, permit, backstory) appears.
2. **Rule Evaluation**: Players check against rules (e.g., "Permit must start with 'P'").
3. **Decision**: Enter `approve` or `deny`.
4. **Feedback**: Veritas provides commentary; score and story state update.
5. **Progression**: Rules grow complex, and story events unfold.

### **Example**
```
Traveler: Kalia Vortez
Permit: P7842
Backstory: Seeking asylum from a volcanic eruption.
Veritas: "The permit is valid, but the backstory seems exaggerated."
> approve
Correct! Points: 1
```

### **Winning and Losing**
- **Win**: Reach a point threshold (e.g., 10) with a positive story outcome.
- **Lose**: Trigger a game-over state (e.g., fired for corruption).

---

## **4. Technical Requirements**
### **Software**
- **Python**: Version 3.8 or higher.
- **Libraries**:
  - `google-generativeai`: For AI content generation.
  - `prompt_toolkit`: For terminal UI.
  - `requests`: Optional, for API fallbacks.
- **Git**: For version control.

### **Hardware**
- **OS**: Windows, macOS, or Linux.
- **RAM**: At least 2GB (minimal load).
- **Internet**: Required for API calls.

### **API Access**
- **Google Gemini AI API**: Obtain a key from Google’s developer portal (see [Section 8](#8-ai-assistant-veritas)).

---

## **5. Setting Up the Development Environment**
Follow these steps to get Veritaminal running locally:

### **Step 1: Install Python**
- Download and install Python 3.8+ from [python.org](https://www.python.org/).
- Verify: `python --version` (or `python3 --version` on some systems).

### **Step 2: Clone the Repository**
- Assuming the project is hosted on GitHub:
  ```bash
  git clone https://github.com/yourusername/veritaminal.git
  cd veritaminal
  ```

### **Step 3: Install Dependencies**
- Create a virtual environment (optional but recommended):
  ```bash
  python -m venv venv
  source venv/bin/activate  # Linux/macOS
  venv\Scripts\activate     # Windows
  ```
- Install required packages:
  ```bash
  pip install -r requirements.txt
  ```
  Sample `requirements.txt`:
  ```
  google-generativeai==0.1.0
  prompt_toolkit==3.0.36
  requests==2.28.1
  ```

### **Step 4: Configure Environment Variables**
- Set your API key:
  ```bash
  export GEMINI_API_KEY="your_api_key_here"  # Linux/macOS
  set GEMINI_API_KEY=your_api_key_here       # Windows
  ```
- Alternatively, create a `.env` file:
  ```
  GEMINI_API_KEY=your_api_key_here
  ```
  Load it in Python using `python-dotenv` (add to `requirements.txt` if used).

### **Step 5: Run the Game**
- Start the game:
  ```bash
  python game/main.py
  ```
- Verify it launches with a welcome message from Veritas.

---

## **6. Project Structure**
Here’s how the codebase is organized:
```
veritaminal/
├── game/
│   ├── __init__.py       # Marks directory as a package
│   ├── main.py          # Entry point and game loop
│   ├── api.py           # Google Gemini API integration
│   ├── gameplay.py      # Document generation and verification
│   ├── narrative.py     # Story state and branching logic
│   └── ui.py            # Terminal interface
├── tests/
│   ├── test_gameplay.py # Unit tests for gameplay
│   └── test_narrative.py# Unit tests for narrative
├── setup.py             # Packaging configuration
├── requirements.txt     # Dependencies
├── .env                 # Environment variables (optional)
└── README.md            # This documentation
```

### **File Descriptions**
- **`main.py`**: Orchestrates the game, calling other modules.
- **`api.py`**: Handles API setup and content generation.
- **`gameplay.py`**: Manages document rules and scoring.
- **`narrative.py`**: Tracks and updates story state.
- **`ui.py`**: Builds the interactive terminal UI.

---

## **7. Core Functionality**
### **7.1 Document Generation**
Documents are generated dynamically using the Google Gemini API.

#### **Code (in `gameplay.py`)**
```python
import random
from game.api import generate_text

def generate_document():
    name = generate_text("Generate a unique traveler name")
    permit = generate_text("Generate a permit number starting with 'P' followed by 4 digits")
    backstory = generate_text("Create a one-sentence backstory for a traveler")
    # Randomly introduce errors (e.g., 30% chance)
    is_valid = random.random() > 0.3 and permit.startswith("P") and len(permit) == 5
    return {"name": name, "permit": permit, "backstory": backstory, "is_valid": is_valid}
```

### **7.2 Commands and Gameplay**
Players interact via commands typed into the terminal.

#### **Supported Commands**
- **`approve`**: Approves the current traveler.
- **`deny`**: Denies the current traveler.
- **`hint`**: Requests a hint from Veritas.
- **`quit`**: Exits the game.

#### **Game Loop (in `main.py`)**
```python
from game.gameplay import generate_document
from game.narrative import update_story_state, check_game_over
from game.ui import display_document, get_user_input

def main():
    points = 0
    while True:
        doc = generate_document()
        display_document(doc)
        decision = get_user_input()
        if decision == "quit":
            break
        is_correct = (decision == "approve" and doc["is_valid"]) or \
                     (decision == "deny" and not doc["is_valid"])
        points += 1 if is_correct else 0
        update_story_state(decision, doc["is_valid"])
        if check_game_over():
            break
        print(f"Points: {points}")
```

### **7.3 Scoring System**
- **Correct Decision**: +1 point.
- **Incorrect Decision**: No points; story state adjusts.
- **Goal**: Reach 10 points without triggering a game-over.

---

## **8. AI Assistant: Veritas**
Veritas enhances gameplay with hints and feedback.

### **Implementation (in `api.py`)**
```python
import os
import google.generativeai as genai

# Configure API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

def generate_text(prompt, max_tokens=50):
    try:
        response = genai.generate_text(prompt=prompt, max_tokens=max_tokens)
        return response.text.strip()
    except Exception as e:
        print(f"API Error: {e}")
        return "Error generating text"

def get_veritas_hint(doc):
    prompt = f"Analyze this traveler: {doc['name']}, {doc['permit']}, {doc['backstory']}"
    return generate_text(prompt)
```

### **Setup**
- **API Key**: Obtain from Google’s developer portal.
- **Error Handling**: Fallback to static text if API fails.

### **Example Output**
```
Veritas: "The permit P1234 is valid, but the backstory seems suspicious."
```

---

## **9. Narrative Branching**
Choices shape the story through a state machine.

### **Story State (in `narrative.py`)**
```python
story_state = {"corruption": 0, "trust": 0}

def update_story_state(decision, is_valid):
    if decision == "approve" and not is_valid:
        story_state["corruption"] += 1
        print("Corruption rises...")
    elif decision == "deny" and is_valid:
        story_state["trust"] -= 1
        print("Trust wanes...")

def check_game_over():
    if story_state["corruption"] >= 3:
        print("Scandal! You’re fired.")
        return True
    if story_state["trust"] <= -3:
        print("No one trusts you. Game over.")
        return True
    return False
```

### **Adding New Paths**
- Modify `update_story_state` to track new variables (e.g., "reputation").
- Update `check_game_over` with new conditions.

---

## **10. Testing and Debugging**
### **Unit Tests (in `tests/`)**
```python
# test_gameplay.py
import unittest
from game.gameplay import generate_document

class TestGameplay(unittest.TestCase):
    def test_generate_document(self):
        doc = generate_document()
        self.assertTrue(isinstance(doc, dict))
        self.assertIn("name", doc)
```

### **Running Tests**
```bash
python -m unittest discover tests
```

### **Debugging Tips**
- Use `pdb`: `python -m pdb game/main.py`.
- Add logging:
  ```python
  import logging
  logging.basicConfig(level=logging.DEBUG)
  logging.debug("Document generated: %s", doc)
  ```

---

## **11. Packaging and Deployment**
### **Setup (in `setup.py`)**
```python
from setuptools import setup
setup(
    name="veritaminal",
    version="1.0.0",
    packages=["game"],
    install_requires=["google-generativeai", "prompt_toolkit"],
    entry_points={"console_scripts": ["veritaminal = game.main:main"]},
)
```

### **Build and Install**
```bash
python setup.py sdist
pip install dist/veritaminal-1.0.0.tar.gz
```

### **Run**
```bash
veritaminal
```

---

## **12. Contributing to the Project**
- **Code Style**: Follow PEP 8 (use `flake8` to check).
- **Pull Requests**: Submit via GitHub with tests and docs.
- **Issues**: Report bugs or suggest features in the tracker.

---

## **13. Troubleshooting**
- **API Fails**: Check `GEMINI_API_KEY` and internet.
- **Slow Performance**: Cache API responses in `api.py`.
- **Command Errors**: Ensure `prompt_toolkit` is installed.

---

## **14. Future Enhancements**
- **Dynamic Rules**: Let Veritas generate rules.
- **Themes**: Add `--theme dystopia` option.
- **Save/Load**: Implement game state persistence.

---

## **15. Appendix: Example Configuration**
### **Sample `.env`**
```
GEMINI_API_KEY=abc123xyz
```

### **Sample `requirements.txt`**
```
google-generativeai==0.1.0
prompt_toolkit==3.0.36
python-dotenv==0.19.2
```

---

This documentation is your one-stop resource for Veritaminal. It’s detailed enough to let you build, debug, and enhance the game without me. If something’s unclear, the code and comments should fill the gaps—happy coding!